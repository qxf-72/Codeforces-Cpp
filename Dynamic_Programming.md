动态规划算法，把原问题视作若干个重叠子问题的逐层递进，每个子问题都构成一个"阶段"，在完成前一个阶段的计算之后，动态规划才会执行下一个阶段的计算。

为了保证计算能够按顺序、不重复的进行，动态规划要求已经求解的子问题不能受到后续阶段的影响——**无后效性**。动态规划的状态空间的遍历构成一张**有向无环图**，遍历顺序是在图上的一个拓扑序——节点对应问题状态，边对应状态之间的转移。

在**求解最优化问题**时，下一个阶段的最优解应该能从前面各个阶段的子问题的最优解中导出——**最优子结构性质**。


# 线性 DP

线性 DP——具有线性划分阶段的 DP，无论状态是一维还是多维，线性 DP 体现为在线性空间上的递推——DP 的各级段沿着各个维度线性增长，从一个或多个边界点开始有方向地向整个状态空间转移、拓展。

经典入门线性 DP：
- LIS 问题
- LCS 问题
- 数字三角形问题

以上几个问题是线性 DP 中最简单的一类，需要计算的对象表现出明显的维度以及有序性，每个状态的求解直接构成一个阶段。只需要在**每个维度上各取一个坐标值作为 DP 的状态**。


**求解线性 DP 方法**

- 先确定"阶段"，在阶段各个维度上各取一个坐标值作为 DP 状态，如果"阶段"不足以表示一个状态，则把所需要的附加状态作为状态的维度。
- 在确定 DP 的状态时，要选用注销掉能够覆盖整个状态空间的"维度集合"。


### 例题

[**271. 杨老师的照相排列 - AcWing题库**](https://www.acwing.com/problem/content/273/)

由于方案中每行每列都升高都是单调的，所以按照从高到低的顺序来安排学生站队。对于当前处理到的学生，可以将其安排到符合以下要求的行中：
- 当前行的人数小于要求的人数，即 $a_i$ < $N_i$
- 放到第一行（最后面那行），或者后一行人数>当前行人数

对于 k 为 5 的问题，有以下状态转移方式：
- 若 $a_1$ < $N_1$ ， $F[a_1+1,a_2,a_3,a_4,a_5]+=F[a_1+1,a_2,a_3,a_4,a_5]$
- 若 $a_i<N_i$ 并且 $a_i<a_{i-1}$ ， $F[...,a_i+1,...]+=F[...,a_i,...]$

<br/>


[**272. 最长公共上升子序列 - AcWing题库**](https://www.acwing.com/problem/content/274/)

**LIS 和 LCS 的综合**。在每一个维度上各取一个坐标作为 DP 的状态 $f[i,j]$ ，注意到仅仅是这样，不能描述完整状态，所以定义公共序列以 $b[j]$ 结尾。得到状态转移方程：

$$
f\left[ i,j \right] =\left\{ \begin{array}{l}
	f\left[ i-1,j \right] \ ,\ a\left[ i \right] \ne b\left[ j \right]\\
	\underset{0\le k<j}{\max}\left\{ f\left[ i-1,k \right] \right\} +1\ ,\\
\end{array}\ a\left[ i \right] =b\left[ j \right] \right. 
$$

从状态转移方程中可以看出，可以使用一个三重循环（i，j，k）。在一个 j 循环（i 不变）时，**k 的决策结合是只增多不减少的**，所以可以维护一个变量，避免重复扫描。


<br/>


> 将一个序列 A 变成**非严格递增**的，至少需要**修改**多少个数？
> 
> 答：总长度  -  最长不降子序列长度


> 将一个序列 A 变成**严格递增**的，至少需要**修改**多少个数？
> 
> 答：构造序列 $B[i]=A[i]-i$ 。总长度 - B 的最长不降子序列长度。


<br/>


[**273. 分级 - AcWing题库**](https://www.acwing.com/problem/content/275/)

首先把问题分解，不妨先求非单调增的情况。将状态的要素（已经处理序列长度）放在 DP 的状态中，**此时不足以进行完整描述一个状态，将所需要的附加信息也作为状态的维度**。

对序列进行离散化得到 $b[j]$ ，第二维 j 的范围降为 N，得到状态转移方程：

$$
f\left[ i,j \right] =\underset{0\le k\le j}{\min}\left\{ f\left[ i-1 \right] \left[ k \right] +|a_i-b_j| \right\} 
$$

由于 k 的决策集合也是单调的，所以可以使用一个变量进行维护。


<br/>


[**274. 移动服务 - AcWing题库**](https://www.acwing.com/problem/content/276/)

在本题中，DP 的阶段就是已经完成的任务数量，通过指派伊戈尔服务员到下一个地点，可以从 i-1 转移到 i 。为了计算指派服务员的花费，必须添加附加的信息——三个服务员的位置，如果把三个服务员的位置全部加入状态中，时间复杂度为 $2000\times 200^3$ ，显然是不可接受的。

第处理完第 i 个请求之后，必定有一个服务员位于 $p[i]$ 中，因此只需要描述两个服务员的位置即可。对于状态 $f[i][x][y]$ ，状态的转移只需要枚举 $x,y,p[i]$ 中哪一个服务员前往处理第 $i+1$ 个服务。

**在确定 dp 状态时，选择最小能够覆盖整个状态空间的维度集合**。

<br/>

[**275. 传纸条 - AcWing题库**](https://www.acwing.com/problem/content/277/)

给定一个 $N\times M$ 的矩阵，需要找到两条从左上角到右下角的路径，每一步只能向右或者向下走，路径经过的格子中的数会被取走（两条路径经过同一个格子，只算一次）。

由于格子只能被取出一次，所以需要同步进行两条路径，将当前路径长度作为一个阶段，为了进行状态的转移，还需要知道两条路径末端的坐标，由于路径长度已知，所以只需要一个横坐标就能确定纵坐标。

$f[i][x_1][x_2]$ 表示两条路径长度均为 $i$ ，两条路径末端分别在第 $x_1$ 和 $x_2$ 行。进行转态转移时，枚举两条路径末端拓展方式，需要处理好两条路径同时进入同一个格子的情况**。在进行状态转移时，需要注意剔除非法的状态**。


<br/>


[**276. I-区域 - AcWing题库**](https://www.acwing.com/problem/content/278/)

显然，可以将"当前选了多少个格子"作为 DP 的状态。由于选的格子构成的区域必须是一个凸的连通块，必须添加额外的信息描述除形状一个状态。

**任意连个凸连通块可以划分为连续的若干行，每行的左端点先递减后递增，每行的右端点先递增后递减。**


所以，DP 的状态包含的信息：
- 当前处理到第几行
- 当前选出来多少个格子
- 当前行选出格子的两个端点
- 两个端点的增减状态


<br/>


[**277. 饼干 - AcWing题库**](https://www.acwing.com/problem/content/279/)

根据贪心算法的思想，怨气值大的孩子应该获得更多的饼干，所以现在根据怨气值大小从大到小排序。


根据问题的阶段可以容易推出 DP 的状态—— $f[i][j]$ 表示前 $i$ 个孩子一共分配 $j$ 块饼干。

问题在于如何进行状态的转移，进行状态的需要知道之前的孩子的饼干分配情况——前一个孩子分配的饼干数，已经有多少个孩子分配的饼干数和前一个孩子相同。如果把这两天附加信息加入 DP 状态，算法的效率不可接受。

其实 $f[i][j]$ 已经足够进行状态的转移。
- **$f[i][j]=f[i][j-i]$ ，即所有孩子同时少分配一块饼干，这并不改变各个孩子获得饼干的大小关系**。

	这个转移关系，只在所有孩子获得的饼干数都大于 1 的时候成立。

- 接下来枚举有获得饼干数量为 1 的孩子都情况：

$$
f\left[ i \right] \left[ j \right] =\underset{0\le k<i}{\min}\left\{ f\left[ k \right] \left[ j-\left( i-k \right) \right] +k\times \sum_{p=k+1}^i{f\left[ p \right]} \right\} 
$$

本题还需要给出一个具体方案，使用一个额外的数组记录当前状态是从哪一个状态转移而来的。**对于目标状态进行回溯找到起点状态，从底往上计算答案**。

---


<br/>


<br/>


<br/>


<br/>


# 背包 DP

背包 DP 是线性 DP 中一类重要而特殊的模型。

## 0/1 背包

**问题模型**——给定 $N$ 个物品，其中第 $i$ 个物品体积和价值分别为 $V_i$ 和 $W_i$ 。有一个容积为 $M$ 的背包，要求选择一些物品放入背包中，使得总体积不超过 $M$ 的前提下，物品价值总和最大。

根据线性 DP 的性质，可以将问题的阶段——已经处理到物品数，作为 DP 的阶段，还需要把放入背包的总体积作为附加信息

$$
f\left[ i \right] \left[ j \right] =\max \left\{ \begin{array}{l}
	f\left[ i-1 \right] \left[ j \right]\\
	f\left[ i-1 \right] \left[ j-V_i \right] +W_i\\
\end{array} \right. 
$$


从以上状态转移方程，可以看出，在进行状态转移方程时，每一阶段 $i$ 只和上一阶段 $i-1$ 的状态有关，可以使用**滚动数组**降低空间开销。

```cpp
const int MAX_N = 1000;  
void bag_dp()  
{  
    int f[2][MAX_N];  
    memset(f, 0xcf, sizeof f);  
    f[0][0] = 0;  
    for (int i = 1; i <= n; ++i)  
    {  
       for (int j = 0; j <= m; ++j)  
          f[i & 1][j] = f[(i - 1) & 1][j];  
       for (int j = 0; j <= m; ++j)  
          f[i & 1][j] = max(f[i & 1][j], f[(i - 1) & 1][j - v[i]] + w[i]);  
    }  
}
```

经过观察，发现其实用一个一维数组已经足够了，但需要注意遍历到顺序——**倒序遍历**。

```cpp
const int MAX_N = 1000;  
void bag_dp()  
{  
    int f[MAX_N];  
    memset(f, 0xcf, sizeof f);  
    f[0] = 0;  
    for (int i = 1; i <= n; ++i)  
    {  
       for (int j = m; j >= 0; --j)  
          f[j] = max(f[j], f[j - v[i]] + w[i]);  
    }  
}
```


### 例题


[**278. 数字组合 - AcWing题库**](https://www.acwing.com/problem/content/280/)



---


<br/>


<br/>


## 完全背包

**问题模型**——在 01 背包的基础上，**物品的数量为无穷**。

和 01 背包DP 的状态设置一样，状态转移方程略有不同

$$
f\left[ i \right] \left[ j \right] =\max \left\{ \begin{array}{l}
	f\left[ i-1 \right] \left[ j \right]\\
	f\left[ i \right] \left[ j-V_i \right] +W_i\\
\end{array} \right. 
$$

同样的，DP 数组可以被压缩为一维，根据状态转移方程，应该**正序遍历**。

### 例题

[**279. 自然数拆分 - AcWing题库**](https://www.acwing.com/problem/content/281/)

典型的完全背包问题，1 到 N 这个 N 个数是 N 个物品，每个数字可以无限使用，背包容积是 N 。

```cpp
#define int long long  
const int mod = 2147483648;  
void solve()  
{  
    int n;  
    cin >> n;  
    int f[n + 1];  
    memset(f, 0, sizeof f);  
    f[0] = 1;  
    for (int i = 1; i <= n; ++i)  
    {  
       for (int j = i; j <= n; ++j)  
          f[j] = (f[j] + f[j - i]) % mod;  
    }  
    cout << (f[n] == 0 ? mod - 1 : f[n] - 1);  
}
```


<br/>


[**280. 陪审团 - AcWing题库**](https://www.acwing.com/problem/content/282/)

该问题可以视为有多个"体积维度"的 0/1 背包问题。把 N 个候选人看作 N 个物品，每个物品有如下三种体积：
- 人数：每个人体积为 1，最终要填满 M。
- 辩方得分
- 控方得分

根据线性 DP 的一般方法，可以设计出来这样的 DP 状态—— $f(i,j,a,b)$ 表示处理完前 $i$ 个人，选出来 $j$ 个人，辩方和控方的总分分别为 $a$ 和 $b$ ，此时是否可行。递推结束之后，在 $f(n,m,-,-)==true$ 中选出 $|a-b|$ 最小且 $a+b$ 最大那个作为答案。

以上算法的"价值"这一维度用一个 `bool` 类型表示状态是否可行，**并没有很好进行利用"价值"这一维度**。可以把辩方和控方得分之差 $a-b$ 作为体积，得分之和 $a+b$ 作为价值。初始化 `f[0][0][0]=0`，其余为负无穷，当价值不为负数时，说明状态可行。

$$
f\left[ j \right] \left[ k \right] =\max \left( f\left[ j \right] \left[ k \right] ,f\left[ j-1 \right] \left[ k-\left( a\left[ i \right] -b\left[ i \right] \right) \right] +a\left[ i \right] +b\left[ i \right] \right) 
$$


---


<br/>


<br/>


## 多重背包

**问题模型**——在 0/1 背包的基础上，第 $i$ 种 物品的数量有 $c_i$ 个 ， $c_i$ 可能大于 1， 但不是无穷。

<br/>

**直接拆分法**

把第 $i$ 种物品看作是 $c_i$ 个独立的物品，转化为 0/1 背包问题，时间复杂度为 $M\times \sum_{i=1}^N{C_i}$ ，效率较低。


<br/>


**二进制拆分法**

已知 从 $2^0,2^1,...,2^{k-1}$ 这 $k$ 个数中选出若干的数，可以表示出 $0$ 到 $2^k-1$ 之间任意整数。设 $2^0+2^1+...+2^p \le c_i$ ， $R=c_i-(2^0+2^1+...+2^p)$ ，则 $2^0,2^1,...,2^p,R$ 可以表示任意 $0$ 到 $c_i$ 的整数，**且不会超出 $c_i$** 。

所以，可以把第 $i$ 件物品拆分为 $p+2$ 件物品。算法时间复杂度为 $M\times \sum_{i=1}^N{log_{C_i}}$ ，效率较高。


<br/>


**单调队列优化**

单调队列优化 DP 求解多重背包问题，可以将时间复杂度进一步降低为 $M\times N$ 。


### 例题

[**281. 硬币 - AcWing题库**](https://www.acwing.com/problem/content/283/)

本题仅仅关注**可行性**，价值维度可以加以利用， $f[i][j]$ 表示在前 $i$ 中硬币中，得到面值为 $j$ ，最少需要多少第 $i$ 种硬币数量。初始 `f[0][0]=0`，其余为正无穷。

$$
f\left[ i \right] \left[ j \right] =\left\{ \begin{array}{l}
	0,\ f\left[ i-1 \right] \left[ j \right] \le c\left[ i-1 \right]\\
	f\left[ i \right] \left[ j-a\left[ i \right] \right] +1\\
\end{array} \right. 
$$

根据状态转移方程，可以进行状态压缩。时间复杂度为 $O(M\times N)$ 。本题卡常数，以上算法并不能通过 。

更好的算法是，使用一个数组 $used[j]$ 表示要让 $f[j]$ 变为 $true$ 至少需要的第 $i$ 种 硬币数量。时间复杂度一样，但是常数更小。

```cpp
bool f[m + 1];  
memset(f, 0, sizeof f);  
int used[m + 1];  
f[0] = true;  
for (int i = 1; i <= n; ++i)  
{  
    for (int j = 0; j <= m; ++j)  
       used[j] = 0;  
    for (int j = a[i]; j <= m; ++j)  
    {  
       if (!f[j] && f[j - a[i]] && used[j - a[i]] < c[i])  
       {  
          f[j] = true;  
          used[j] = used[j - a[i]] + 1;  
       }  
    }  
}  
int ans = 0;  
for (int i = 1; i <= m; ++i)  
    if (f[i]) ++ans;  
cout << ans << '\n';
```

---


<br/>


<br/>


## 分组背包

**问题模型**——给定 $N$ 组物品，其中第 $i$ 组有 $C_i$ 个物品，第 $i$ 组的第 $j$ 个物品的体积和价值分别为 $V_{ij}$ 和 $W_{ij}$ ，每组最多可以选一个物品并且物品总体积不超过 $M$ 的情况下，求物品最大价值总和。


$f(i,j)$ 表示在前 $i$ 组中，选出体积为 $j$ 的物品的最大价值总和

$$
f\left( i,j \right) =\max \left\{ \begin{array}{l}
	f\left( i-1,j \right) ,\ \text{不选第}i\text{组物品}\\
	\underset{1\le k\le C_i}{\max}f\left( i-1,j-V_{ik} \right) +W_{ik},\ \text{选}i\text{组第}k\text{个}\\
\end{array} \right. 
$$

同样的阶段 $i$ 从阶段 $i-1$ 转移而来，所以可以省略数组的第一位，第二维使用倒序遍历。




---