动态规划算法，把原问题视作若干个重叠子问题的逐层递进，每个子问题都构成一个"阶段"，在完成前一个阶段的计算之后，动态规划才会执行下一个阶段的计算。

为了保证计算能够按顺序、不重复的进行，动态规划要求已经求解的子问题不能受到后续阶段的影响——**无后效性**。动态规划的状态空间的遍历构成一张**有向无环图**，遍历顺序是在图上的一个拓扑序——节点对应问题状态，边对应状态之间的转移。

在**求解最优化问题**时，下一个阶段的最优解应该能从前面各个阶段的子问题的最优解中导出——**最优子结构性质**。


# 线性 DP

线性 DP——具有线性划分阶段的 DP，无论状态是一维还是多维，线性 DP 体现为在线性空间上的递推——DP 的各级段沿着各个维度线性增长，从一个或多个边界点开始有方向地向整个状态空间转移、拓展。

经典入门线性 DP：
- LIS 问题
- LCS 问题
- 数字三角形问题

以上几个问题是线性 DP 中最简单的一类，需要计算的对象表现出明显的维度以及有序性，每个状态的求解直接构成一个阶段。只需要在**每个维度上各取一个坐标值作为 DP 的状态**。


### 例题

[**271. 杨老师的照相排列 - AcWing题库**](https://www.acwing.com/problem/content/273/)

由于方案中每行每列都升高都是单调的，所以按照从高到低的顺序来安排学生站队。对于当前处理到的学生，可以将其安排到符合以下要求的行中：
- 当前行的人数小于要求的人数，即 $a_i$ < $N_i$
- 放到第一行（最后面那行），或者后一行人数>当前行人数

对于 k 为 5 的问题，有以下状态转移方式：
- 若 $a_1$ < $N_1$ ， $F[a_1+1,a_2,a_3,a_4,a_5]+=F[a_1+1,a_2,a_3,a_4,a_5]$
- 若 $a_i<N_i$ 并且 $a_i<a_{i-1}$ ， $F[...,a_i+1,...]+=F[...,a_i,...]$

<br/>


[**272. 最长公共上升子序列 - AcWing题库**](https://www.acwing.com/problem/content/274/)

**LIS 和 LCS 的综合**。在每一个维度上各取一个坐标作为 DP 的状态 $f[i,j]$ ，注意到仅仅是这样，不能描述完整状态，所以定义公共序列以 $b[j]$ 结尾。得到状态转移方程：

$$
f\left[ i,j \right] =\left\{ \begin{array}{l}
	f\left[ i-1,j \right] \ ,\ a\left[ i \right] \ne b\left[ j \right]\\
	\underset{0\le k<j}{\max}\left\{ f\left[ i-1,k \right] \right\} +1\ ,\\
\end{array}\ a\left[ i \right] =b\left[ j \right] \right. 
$$

从状态转移方程中可以看出，可以使用一个三重循环（i，j，k）。在一个 j 循环（i 不变）时，**k 的决策结合是只增多不减少的**，所以可以维护一个变量，避免重复扫描。


<br/>


> 将一个序列 A 变成**非严格递增**的，至少需要**修改**多少个数？
> 
> 答：总长度  -  最长不降子序列长度


> 将一个序列 A 变成**严格递增**的，至少需要**修改**多少个数？
> 
> 答：构造序列 $B[i]=A[i]-i$ 。总长度 - B 的最长不降子序列长度。


<br/>


[**273. 分级 - AcWing题库**](https://www.acwing.com/problem/content/275/)

首先把问题分解，不妨先求非单调增的情况。将状态的要素（已经处理序列长度）放在 DP 的状态中，**此时不足以进行完整描述一个状态，将所需要的附加信息也作为状态的维度**。

对序列进行离散化得到 $b[j]$ ，第二维 j 的范围降为 N，得到状态转移方程：

$$
f\left[ i,j \right] =\underset{0\le k\le j}{\min}\left\{ f\left[ i-1 \right] \left[ k \right] +|a_i-b_j| \right\} \ 
$$

由于 k 的决策集合也是单调的，所以可以使用一个变量进行维护。


<br/>


[**274. 移动服务 - AcWing题库**](https://www.acwing.com/problem/content/276/)

在本题中，DP 的阶段就是已经完成的任务数量，通过指派伊戈尔服务员到下一个地点，可以从 i-1 转移到 i 。为了计算指派服务员的花费，必须添加附加的信息——三个服务员的位置，如果把三个服务员的位置全部加入状态中，时间复杂度为 $2000\times 200^3$ ，显然是不可接受的。

第处理完第 i 个请求之后，必定有一个服务员位于 $p[i]$ 中，因此只需要描述两个服务员的位置即可。对于状态 $f[i][x][y]$ ，状态的转移只需要枚举 $x,y,p[i]$ 中哪一个服务员前往处理第 $i+1$ 个服务。

**在确定 dp 状态时，选择最小能够覆盖整个状态空间的维度集合**。

<br/>

[**275. 传纸条 - AcWing题库**](https://www.acwing.com/problem/content/277/)

给定一个 $N\times M$ 的矩阵，需要找到两条从左上角到右下角的路径，每一步只能向右或者向下走，路径经过的格子中的数会被取走（两条路径经过同一个格子，只算一次）。

由于格子只能被取出一次，所以需要同步进行两条路径，将当前路径长度作为一个阶段，为了进行状态的转移，还需要知道两条路径末端的坐标，由于路径长度已知，所以只需要一个横坐标就能确定纵坐标。

$f[i][x_1][x_2]$ 表示两条路径长度均为 $i$ ，两条路径末端分别在第 $x_1$ 和 $x_2$ 行。进行转态转移时，枚举两条路径末端拓展方式，需要处理好两条路径同时进入同一个格子的情况**。在进行状态转移时，需要注意剔除非法的状态**。


<br/>


[**276. I-区域 - AcWing题库**](https://www.acwing.com/problem/content/278/)

显然，可以将"当前选了多少个格子"作为 DP 的状态。由于选的格子构成的区域必须是一个凸的连通块，必须添加额外的信息描述除形状一个状态。

**任意连个凸连通块可以划分为连续的若干行，每行的左端点先递减后递增，每行的右端点先递增后递减。**


所以，DP 的状态包含的信息：
- 当前处理到第几行
- 当前选出来多少个格子
- 当前行选出格子的两个端点
- 两个端点的增减状态


<br/>


[**277. 饼干 - AcWing题库**](https://www.acwing.com/problem/content/279/)

根据贪心算法的思想，怨气值大的孩子应该获得更多的饼干，所以现在根据怨气值大小从大到小排序。


根据问题的阶段可以容易推出 DP 的状态—— $f[i][j]$ 表示前 $i$ 个孩子一共分配 $j$ 块饼干。

问题在于如何进行状态的转移，进行状态的需要知道之前的孩子的饼干分配情况——前一个孩子分配的饼干数，已经有多少个孩子分配的饼干数和前一个孩子相同。如果把这两天附加信息加入 DP 状态，算法的效率不可接受。

其实 $f[i][j]$ 已经足够进行状态的转移。
- ** $f[i][j]=f[i][j-i]$ ，即所有孩子同时少分配一块饼干，这并不改变各个孩子获得饼干的大小关系**。

	这个转移关系，只在所有孩子获得的饼干数都大于 1 的时候成立。

- 接下来枚举有获得饼干数量为 1 的孩子都情况：

$$
f\left[ i \right] \left[ j \right] =\underset{0\le k<i}{\min}\left\{ f\left[ k \right] \left[ j-\left( i-k \right) \right] +k\times \sum_{p=k+1}^i{f\left[ p \right]} \right\} 
$$

本题还需要给出一个具体方案，使用一个额外的数组记录当前状态是从哪一个状态转移而来的。**对于目标状态进行回溯找到起点状态，从底往上计算答案**。

---
