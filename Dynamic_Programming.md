动态规划算法，把原问题视作若干个重叠子问题的逐层递进，每个子问题都构成一个"阶段"，在完成前一个阶段的计算之后，动态规划才会执行下一个阶段的计算。

为了保证计算能够按顺序、不重复的进行，动态规划要求已经求解的子问题不能受到后续阶段的影响——**无后效性**。动态规划的状态空间的遍历构成一张**有向无环图**，遍历顺序是在图上的一个拓扑序——节点对应问题状态，边对应状态之间的转移。

在**求解最优化问题**时，下一个阶段的最优解应该能从前面各个阶段的子问题的最优解中导出——**最优子结构性质**。


<br/>


<br/>


# 线性 DP

线性 DP——具有线性划分阶段的 DP，无论状态是一维还是多维，线性 DP 体现为在线性空间上的递推——DP 的各级段沿着各个维度线性增长，从一个或多个边界点开始有方向地向整个状态空间转移、拓展。

经典入门线性 DP：
- 最长上升子序列 LIS 问题
- 最长公共子序列 LCS 问题
- 数字三角形问题

以上几个问题是线性 DP 中最简单的一类，需要计算的对象表现出明显的维度以及有序性，每个状态的求解直接构成一个阶段。只需要在**每个维度上各取一个坐标值作为 DP 的状态**。


**求解线性 DP 方法**

- 先确定"阶段"，<span style="background:#fff88f">在阶段各个维度上各取一个坐标值作为 DP 状态，如果"阶段"不足以表示一个状态，则把所需要的附加状态作为状态的维度</span>。
- 在确定 DP 的状态时，<span style="background:#fff88f">选用最小掉能够覆盖整个状态空间的"维度集合"</span>。


<br/>


### 例题

[**271. 杨老师的照相排列 - AcWing题库**](https://www.acwing.com/problem/content/273/)

由于方案中每行每列都升高都是单调的，所以按照从高到低的顺序来安排学生站队。对于当前处理到的学生，可以将其安排到符合以下要求的行中：
- 当前行的人数小于要求的人数，即 $a_i$ < $N_i$
- 放到第一行（最后面那行），或者后一行人数>当前行人数

对于 k 为 5 的问题，有以下状态转移方式：
- 若 $a_1$ < $N_1$ ， $F[a_1+1,a_2,a_3,a_4,a_5]+=F[a_1+1,a_2,a_3,a_4,a_5]$
- 若 $a_i<N_i$ 并且 $a_i<a_{i-1}$ ， $F[...,a_i+1,...]+=F[...,a_i,...]$


<br/>


[**272. 最长公共上升子序列 - AcWing题库**](https://www.acwing.com/problem/content/274/)

**LIS 和 LCS 的综合**。在每一个维度上各取一个坐标作为 DP 的状态 $f[i,j]$ ，注意到仅仅是这样，不能描述完整状态，所以定义公共序列以 $b[j]$ 结尾。得到状态转移方程：

$$
f\left[ i,j \right] =\left\{ \begin{array}{l}
	f\left[ i-1,j \right] \ ,\ a\left[ i \right] \ne b\left[ j \right]\\
	\underset{0\le k<j}{\max}\left\{ f\left[ i-1,k \right] \right\} +1\ ,\\
\end{array}\ a\left[ i \right] =b\left[ j \right] \right. 
$$

从状态转移方程中可以看出，可以使用一个三重循环（i，j，k）。在一个 j 循环（i 不变）时，**k 的决策结合是只增多不减少的**，所以可以维护一个变量，避免重复扫描。





> 将一个序列 A 变成**非严格递增**的，至少需要**修改**多少个数？
> 
> 答：总长度  -  最长不降子序列长度
> 
> 
> <span style="background:#fff88f">将一个序列 A 变成**严格递增**的，至少需要**修改**多少个数？</span>
> 
> 答：构造序列 $B[i]=A[i]-i$ 。总长度 - B 的最长不降子序列长度。


<br/>


[**273. 分级 - AcWing题库**](https://www.acwing.com/problem/content/275/)

首先把问题分解，不妨先求非单调增的情况。将状态的要素（已经处理序列长度）放在 DP 的状态中，**此时不足以进行完整描述一个状态，将所需要的附加信息也作为状态的维度**。

对序列进行离散化得到 $b[j]$ ，第二维 j 的范围降为 N，得到状态转移方程：

$$
f\left[ i,j \right] =\underset{0\le k\le j}{\min}\left\{ f\left[ i-1 \right] \left[ k \right] +|a_i-b_j| \right\} 
$$

由于 k 的决策集合也是单调的，所以可以使用一个变量进行维护。


<br/>


[**274. 移动服务 - AcWing题库**](https://www.acwing.com/problem/content/276/)

在本题中，DP 的阶段就是已经完成的任务数量，通过指派伊戈尔服务员到下一个地点，可以从 i-1 转移到 i 。为了计算指派服务员的花费，必须添加附加的信息——三个服务员的位置，如果把三个服务员的位置全部加入状态中，时间复杂度为 $2000\times 200^3$ ，显然是不可接受的。

第处理完第 i 个请求之后，必定有一个服务员位于 $p[i]$ 中，因此只需要描述两个服务员的位置即可。对于状态 $f[i][x][y]$ ，状态的转移只需要枚举 $x,y,p[i]$ 中哪一个服务员前往处理第 $i+1$ 个服务。

<span style="background:#fff88f">在确定 dp 状态时，选择最小能够覆盖整个状态空间的维度集合。</span>

<br/>

[**275. 传纸条 - AcWing题库**](https://www.acwing.com/problem/content/277/)

给定一个 $N\times M$ 的矩阵，需要找到两条从左上角到右下角的路径，每一步只能向右或者向下走，路径经过的格子中的数会被取走（两条路径经过同一个格子，只算一次）。

由于格子只能被取出一次，所以需要同步进行两条路径，将当前路径长度作为一个阶段，为了进行状态的转移，还需要知道两条路径末端的坐标，由于路径长度已知，所以只需要一个横坐标就能确定纵坐标。

$f[i][x_1][x_2]$ 表示两条路径长度均为 $i$ ，两条路径末端分别在第 $x_1$ 和 $x_2$ 行。进行转态转移时，枚举两条路径末端拓展方式，需要处理好两条路径同时进入同一个格子的情况**。在进行状态转移时，需要注意剔除非法的状态**。


<br/>


[**276. I-区域 - AcWing题库**](https://www.acwing.com/problem/content/278/)

显然，可以将"当前选了多少个格子"作为 DP 的状态。由于选的格子构成的区域必须是一个凸的连通块，必须添加额外的信息描述除形状一个状态。

<span style="background:#fff88f">任意连个凸连通块可以划分为连续的若干行，每行的左端点先递减后递增，每行的右端点先递增后递减。</span>


所以，DP 的状态包含的信息：
- 当前处理到第几行
- 当前选出来多少个格子
- 当前行选出格子的两个端点
- 两个端点的增减状态


<br/>


[**277. 饼干 - AcWing题库**](https://www.acwing.com/problem/content/279/)

根据贪心算法的思想，怨气值大的孩子应该获得更多的饼干，所以现在根据怨气值大小从大到小排序。


根据问题的阶段可以容易推出 DP 的状态—— $f[i][j]$ 表示前 $i$ 个孩子一共分配 $j$ 块饼干。

问题在于如何进行状态的转移，进行状态的需要知道之前的孩子的饼干分配情况——前一个孩子分配的饼干数，已经有多少个孩子分配的饼干数和前一个孩子相同。如果把这两天附加信息加入 DP 状态，算法的效率不可接受。

其实 $f[i][j]$ 已经足够进行状态的转移。
- **$f[i][j]=f[i][j-i]$ ，即所有孩子同时少分配一块饼干，这并不改变各个孩子获得饼干的大小关系**。

	这个转移关系，只在所有孩子获得的饼干数都大于 1 的时候成立。

- 接下来枚举有获得饼干数量为 1 的孩子都情况：

$$
f\left[ i \right] \left[ j \right] =\underset{0\le k<i}{\min}\left\{ f\left[ k \right] \left[ j-\left( i-k \right) \right] +k\times \sum_{p=k+1}^i{f\left[ p \right]} \right\} 
$$

本题还需要给出一个具体方案，使用一个额外的数组记录当前状态是从哪一个状态转移而来的。<span style="background:#fff88f">**对于目标状态进行回溯找到起点状态，从底往上计算答案**。</span>



<br/>


[**312. 乌龟棋 - AcWing题库**](https://www.acwing.com/problem/content/314/)

线性 DP，在设计状态时，使用最小能够覆盖状态空间的维度集合。

在本题中，只需要设置前 3 中卡片使用情况的状态维度即可，第 4 种卡片的使用情况，可以从前 3 种中推出来。


<br/>

[**313. 花店橱窗 - AcWing题库**](https://www.acwing.com/problem/content/315/)

简单线性 DP 在进行状态转移时记录由哪种状态转移而来，便于输出方案。

---


<br/>


<br/>


<br/>


<br/>


# 背包 DP

背包 DP 是线性 DP 中一类重要而特殊的模型。

## 0/1 背包

**问题模型**——给定 $N$ 个物品，其中第 $i$ 个物品体积和价值分别为 $V_i$ 和 $W_i$ 。有一个容积为 $M$ 的背包，要求选择一些物品放入背包中，使得总体积不超过 $M$ 的前提下，物品价值总和最大。

根据线性 DP 的性质，可以将问题的阶段——已经处理到物品数，作为 DP 的阶段，还需要把放入背包的总体积作为附加信息

$$
f\left[ i \right] \left[ j \right] =\max \left\{ \begin{array}{l}
	f\left[ i-1 \right] \left[ j \right]\\
	f\left[ i-1 \right] \left[ j-V_i \right] +W_i\\
\end{array} \right. 
$$


从以上状态转移方程，可以看出，在进行状态转移方程时，每一阶段 $i$ 只和上一阶段 $i-1$ 的状态有关，可以使用**滚动数组**降低空间开销。

```cpp
const int MAX_N = 1000;  
void bag_dp()  
{  
    int f[2][MAX_N];  
    memset(f, 0xcf, sizeof f);  
    f[0][0] = 0;  
    for (int i = 1; i <= n; ++i)  
    {  
       for (int j = 0; j <= m; ++j)  
          f[i & 1][j] = f[(i - 1) & 1][j];  
       for (int j = 0; j <= m; ++j)  
          f[i & 1][j] = max(f[i & 1][j], f[(i - 1) & 1][j - v[i]] + w[i]);  
    }  
}
```

经过观察，发现其实用一个一维数组已经足够了，但需要注意遍历到顺序——**倒序遍历**。

```cpp
const int MAX_N = 1000;  
void bag_dp()  
{  
    int f[MAX_N];  
    memset(f, 0xcf, sizeof f);  
    f[0] = 0;  
    for (int i = 1; i <= n; ++i)  
    {  
       for (int j = m; j >= 0; --j)  
          f[j] = max(f[j], f[j - v[i]] + w[i]);  
    }  
}
```


### 例题


[**278. 数字组合 - AcWing题库**](https://www.acwing.com/problem/content/280/)


---

<br/>


<br/>


<br/>


## 完全背包

**问题模型**——在 01 背包的基础上，**物品的数量为无穷**。

和 01 背包DP 的状态设置一样，状态转移方程略有不同

$$
f\left[ i \right] \left[ j \right] =\max \left\{ \begin{array}{l}
	f\left[ i-1 \right] \left[ j \right]\\
	f\left[ i \right] \left[ j-V_i \right] +W_i\\
\end{array} \right. 
$$

同样的，DP 数组可以被压缩为一维，根据状态转移方程，应该**正序遍历**。

### 例题

[**279. 自然数拆分 - AcWing题库**](https://www.acwing.com/problem/content/281/)

典型的完全背包问题，1 到 N 这个 N 个数是 N 个物品，每个数字可以无限使用，背包容积是 N 。

```cpp
#define int long long  
const int mod = 2147483648;  
void solve()  
{  
    int n;  
    cin >> n;  
    int f[n + 1];  
    memset(f, 0, sizeof f);  
    f[0] = 1;  
    for (int i = 1; i <= n; ++i)  
    {  
       for (int j = i; j <= n; ++j)  
          f[j] = (f[j] + f[j - i]) % mod;  
    }  
    cout << (f[n] == 0 ? mod - 1 : f[n] - 1);  
}
```


<br/>


[**280. 陪审团 - AcWing题库**](https://www.acwing.com/problem/content/282/)

该问题可以视为有多个"体积维度"的 0/1 背包问题。把 N 个候选人看作 N 个物品，每个物品有如下三种体积：
- 人数：每个人体积为 1，最终要填满 M。
- 辩方得分
- 控方得分

根据线性 DP 的一般方法，可以设计出来这样的 DP 状态—— $f(i,j,a,b)$ 表示处理完前 $i$ 个人，选出来 $j$ 个人，辩方和控方的总分分别为 $a$ 和 $b$ ，此时是否可行。递推结束之后，在 $f(n,m,-,-)==true$ 中选出 $|a-b|$ 最小且 $a+b$ 最大那个作为答案。

以上算法的"价值"这一维度用一个 `bool` 类型表示状态是否可行，**并没有很好进行利用"价值"这一维度**。可以把辩方和控方得分之差 $a-b$ 作为体积，得分之和 $a+b$ 作为价值。初始化 `f[0][0][0]=0`，其余为负无穷，当价值不为负数时，说明状态可行。

$$
f\left[ j \right] \left[ k \right] =\max \left( f\left[ j \right] \left[ k \right] ,f\left[ j-1 \right] \left[ k-\left( a\left[ i \right] -b\left[ i \right] \right) \right] +a\left[ i \right] +b\left[ i \right] \right) 
$$


---


<br/>


<br/>


<br/>


## 多重背包

**问题模型**——在 0/1 背包的基础上，第 $i$ 种 物品的数量有 $c_i$ 个 ， $c_i$ 可能大于 1， 但不是无穷。

<br/>

**直接拆分法**

把第 $i$ 种物品看作是 $c_i$ 个独立的物品，转化为 0/1 背包问题，时间复杂度为 $M\times \sum_{i=1}^N{C_i}$ ，效率较低。


<br/>


**二进制拆分法**

已知 从 $2^0,2^1,...,2^{k-1}$ 这 $k$ 个数中选出若干的数，可以表示出 $0$ 到 $2^k-1$ 之间任意整数。设 $2^0+2^1+...+2^p \le c_i$ ， $R=c_i-(2^0+2^1+...+2^p)$ ，则 $2^0,2^1,...,2^p,R$ 可以表示任意 $0$ 到 $c_i$ 的整数，**且不会超出 $c_i$** 。

所以，可以把第 $i$ 件物品拆分为 $p+2$ 件物品。算法时间复杂度为 $M\times \sum_{i=1}^N{log_{C_i}}$ ，效率较高。


<br/>


**单调队列优化**

单调队列优化 DP 求解多重背包问题，可以将时间复杂度进一步降低为 $M\times N$ 。


### 例题

[**281. 硬币 - AcWing题库**](https://www.acwing.com/problem/content/283/)

<span style="background:#fff88f">本题仅仅关注**可行性**，价值维度可以加以利用</span>， $f[i][j]$ 表示在前 $i$ 中硬币中，得到面值为 $j$ ，最少需要多少第 $i$ 种硬币数量。初始 `f[0][0]=0`，其余为正无穷。

$$
f\left[ i \right] \left[ j \right] =\left\{ \begin{array}{l}
	0,\ f\left[ i-1 \right] \left[ j \right] \le c\left[ i-1 \right]\\
	f\left[ i \right] \left[ j-a\left[ i \right] \right] +1\\
\end{array} \right. 
$$

根据状态转移方程，可以进行状态压缩。时间复杂度为 $O(M\times N)$ 。本题卡常数，以上算法并不能通过 。

更好的算法是，使用一个数组 $used[j]$ 表示要让 $f[j]$ 变为 $true$ 至少需要的第 $i$ 种 硬币数量。时间复杂度一样，但是常数更小。

```cpp
bool f[m + 1];  
memset(f, 0, sizeof f);  
int used[m + 1];  
f[0] = true;  
for (int i = 1; i <= n; ++i)  
{  
    for (int j = 0; j <= m; ++j)  
       used[j] = 0;  
    for (int j = a[i]; j <= m; ++j)  
    {  
       if (!f[j] && f[j - a[i]] && used[j - a[i]] < c[i])  
       {  
          f[j] = true;  
          used[j] = used[j - a[i]] + 1;  
       }  
    }  
}  
int ans = 0;  
for (int i = 1; i <= m; ++i)  
    if (f[i]) ++ans;  
cout << ans << '\n';
```

---


<br/>


<br/>


<br/>


## 分组背包

**问题模型**——给定 $N$ 组物品，其中第 $i$ 组有 $C_i$ 个物品，第 $i$ 组的第 $j$ 个物品的体积和价值分别为 $V_{ij}$ 和 $W_{ij}$ ，每组最多可以选一个物品并且物品总体积不超过 $M$ 的情况下，求物品最大价值总和。


$f(i,j)$ 表示在前 $i$ 组中，选出体积为 $j$ 的物品的最大价值总和

$$
f\left( i,j \right) =\max \left\{ \begin{array}{l}
	f\left( i-1,j \right) ,\ \text{不选第}i\text{组物品}\\
	\underset{1\le k\le C_i}{\max}f\left( i-1,j-V_{ik} \right) +W_{ik},\ \text{选}i\text{组第}k\text{个}\\
\end{array} \right. 
$$

同样的阶段 $i$ 从阶段 $i-1$ 转移而来，所以可以省略数组的第一位，第二维使用倒序遍历。


---


<br/>


<br/>


<br/>


<br/>


# 区间 DP

区间 DP 也属于线性 DP 的一种，以**区间长度**作为 DP 的阶段，使用两个坐标（区间端点）描述每个维度，**一个状态由若干个比它更小且包含于它的区间所代表的状态转移而来
**。区间 DP 的初态一般由长度为 1 的**元区间**构成。

区间 DP 先预处理元区间，然后从区间长度 $len$ 为 2 开始递推，每一步枚举长度为 $len$ 区间的起点，最后递推到 $len=n$ 结束。


### 例题

[**282. 石子合并 - AcWing题库**](https://www.acwing.com/problem/content/284/)

任何对于石子可以使用一个区间 $[l,r]$ 表示，区间 $[l,r]$ 被合并成一堆之前，有区间 $[l,k]$ 和 $[k+1,r]$ 各自被合并成一堆，然后将这两堆合并成对于。

$f(l,r)$ 表示将区间 $[l,r]$ 合并的代价，转移方程为：

$$
f\left( l,r \right) =\underset{l\le k<r}{\min}\left\{ f\left[ l,r \right] +f\left( k+1,r \right) \right\} +\sum_{i=l}^r{a_i}
$$

初始状态为 $f(i,i)=0$ ，根据区间长度从小往大递推，对于每个区间长度，枚举端点。

```cpp
for (int len = 2; len <= n; ++len)  
{  
    for (int l = 1; l + len - 1 <= n; ++l)  
    {  
       int r = l + len - 1;  
       for (int k = l; k < r; ++k)  
          f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]);  
       f[l][r] += a[r] - a[l - 1];  
    }  
}
```

本题也可以使用记忆化搜索。


<br/>


[**283. 多边形 - AcWing题库**](https://www.acwing.com/problem/content/285/)

在本题中，序列是一个环形结构，对于一个环形结构，第一步中先选一条边进行删除，断开之后就是链状结构，有两种方法：
- 可以枚举每一个断开的位置。时间复杂度为 $O(N\times N^2)$ 。
- **解决环形结构更通用的办法时，复制形成 2 倍长的链**。时间复杂度为 $O((2N)^2)$ ，显然效率更高。

本题中，由于存在乘法运算符，一个很大的值可以是两个很小的负值相乘得到，需要考虑每个区间的极小值。


<br/>

[**284. 金字塔 - AcWing题库**](https://www.acwing.com/problem/content/286/)

显然，在本题中应设 $f(l,r)$ 为 $s[l,r]$ 对应的树状结构数量，关键在于如何进行状态的转移，如果将一棵树分为两半，枚举划分点，这样会进行重复的计数。**为了不重不漏的计算，可以只考虑 $s[l,r]$ 的第一颗子树是由哪一段构成的**，如果第一颗子树不同，那么不可能产生同样的结构。

可以使用记忆化搜索实现。

```cpp
using LL = long long;
const int mod = 1'000'000'000;

string s;
LL f[310][310];

LL func(int l, int r)
{
	if (f[l][r] != -1)
		return f[l][r];
	if (l > r || s[l] != s[r])
		return f[l][r] = 0;
	if (l == r)
		return f[l][r] = 1;
	f[l][r] = 0;
	for (int k = l + 2; k <= r; ++k)
	{
		// func(l+1,r-1)是第1颗子树可能的形状数量
		f[l][r] = (f[l][r] + func(l + 1, k - 1) * func(k, r)) % mod;
	}
	return f[l][r];
}

signed main()
{
	cin >> s;
	memset(f, -1, sizeof f);
	cout << func(0, s.size() - 1);
	return 0;
}

```

---


<br/>


<br/>


<br/>


<br/>


# 树形 DP

## 普通树形DP

给定以颗有 $N$ 个节点的树（ $N-1$ 条边，通常是无根树 ），我们可以选一个节点作为根节点，从而定义出每个节点的深度和每颗子树的根，在树上设计动态规划算法，**一般以节点从浅到深（子树从小到大）的顺序作为 DP 的阶段**。DP 状态第一维通常是节点编号。

通常采用递归的方式实现树形 DP，对于每个节点，先递归处理其子节点，计算好当前节点之后，向父节点进行状态的转移。**即 DFS，不需要记忆化搜索，在树形结构中，每一个阶段不会被重复计算**。

还可以使用自底向上的拓扑序列来执行树形 DP。对于无根树，需要注意标记节点是否访问过，避免在遍历中沿着反向边回到父节点。

### 例题

[**285. 没有上司的舞会 - AcWing题库**](https://www.acwing.com/problem/content/287/)

$f(x,0)$ 表示以 $x$ 为根节点的树且不选 $x$ 的情况下，获得的最大快乐值总和。 $f(x,1)$ 表示以 $x$ 为根节点的树且选 $x$ 的情况下，获得的最大快乐值总和。

不选根节点的情况下，子节点可选可不选，选根节点的情况下，子节点必然不可选。

---


<br/>


<br/>


<br/>


## 背包类树形DP

背包类树形 DP 是一类特殊的树形 DP，在计算节点 $F[x]$ 时，将其各个子树 $y_i$ 看作是分组的背包。


### 例题

[**286. 选课 - AcWing题库**](https://www.acwing.com/problem/content/288/)

可以将课抽象为森林，将每一颗树视为一个分组。

在本题中，可以将一棵树前几个节点（从根往下）看作是一个整体，体积为节点的数量，价值需要先对子树递归计算得到。

总之就是在森林中进行分组背包动态规划， 不过需要先递归计算子树。

```cpp
void dp(int x) {
    f[x][0] = 0;
    for (auto y : son[x]) {
        dp(y); // 递归计算子树
        // 枚举背包体积, 由于进行了空间压缩所以需要倒序枚举
        for (int t = m; t >= 0; --t) {
            // 枚举物品
            for (int j = 0; j <= t; ++j) {
                f[x][t] = max(f[x][t], f[x][t - j] + f[y][j]);
            }
        }
    }
    if (x != 0) {
        for (int t = m; t > 0; --t)
            f[x][t] = f[x][t - 1] + score[x];
    }
}
```


---


<br/>


<br/>


<br/>


## 换根 DP

之前的树形 DP 都是在有根树上进行动态规划。当问题的对象是无根树，即，需要考虑以不同节点为根的情况。

此时使用换根 DP，步骤为：
- 随便取一个节点作为树的根，进行 DP
- 进行二次扫描，根据第一次 DP 的结果，推出以每一个节点作为根的结果


<br/>



[**287. 积蓄程度 - AcWing题库**](https://www.acwing.com/problem/content/289/)


经典换根 DP。二次扫描是需要注意边界情况。

---


<br/>


<br/>


<br/>


<br/>


# 环形与后效性处理

## 环形结构上的 DP

大部分环形结构的问题中，都可以通过枚举，选择一个位置断开，变成线性结构进行计算。这种问题成为——**可拆解的环形问题**。对于这种问题，要选择合适的策略避免枚举，从而降低时间复杂度，策略有：
- 将问题拆解，分成环和不成换的情况进行考虑，最后将答案合并。
- 将环断开成链状，复制一份拼接到末尾，在该序列上进行 DP。

### 例题

[**288. 休息时间 - AcWing题库**](https://www.acwing.com/problem/content/290/)

设 $F[i][j][0]$ 表示前 $i$ 个小时休息了 $j$ 个小时，并且第 $i$ 个小时没有在休息， $F[i][j][1]$ 同理。

将问题拆解
- 先不考虑成环的情况，则 $F[1][0][0]=F[1][1][1]=0$ ，目标是 $max(F[N][B][0],F[N][B][1])$ 。
- 上面几乎覆盖了全部的情况，唯独漏了，一天最后一个小时和第一个小时同时在休息的情况，所以可以强制这两个小时在休息进行递推，初始 $F[1][1][1]=U_1$ ，目标是 $F[N][B][1]$ 。

上诉两种情况可以覆盖全部情况。最后将答案合并。


<br/>


[**289. 环路运输 - AcWing题库**](https://www.acwing.com/problem/content/291/)

采用第二种策略，将环路断开，复制一倍拼接到末尾。此时如果 $i-j<=n/2$ ，则继续在 $i,j$ 之间运输，否则在 $i,j+n$ 之间运输。问题转化为在长度为 $2n$ 的序列上，满足 $1\le j<i\le 2*n$ ，并且 $i-j\le n/2$ ， $A_i+i+A_j-j$ 的最大值。可以使用单调队列解决。


---


<br/>


<br/>


<br/>


## 有后效性的状态转移

无后效性是使用动态规划算法的前提。但是有些形似 DP 的题目，却不满足无后效性——部分状态之间相互转移、相互影响。

如果仅仅是无后效性不能满足，且状态转移都是一次方程。可以把各状态看作未知量，状态转移看作各个方程，不采用线性递推，直接用高斯消元求出转移方程的解。

如果动态规划状态转移分阶段带环，需要把 DP 和高斯消元结合起来——整体采用动态规划框架，局部使用高斯消元解出相互影响的状态。

### 例题

[**290. 坏掉的机器人 - AcWing题库**](https://www.acwing.com/problem/content/description/292/)

在行的维度上的状态转移，依然满足无后效性，但是在同一行中，机器人即可以左右走，还可以不动。

数学期望 DP 采用倒推的方式执行，在计算第 $i$ 行时，第 $i+1$ 行的情况是已知，可以看作是常数。根据题意，对于该行每个位置都可以建立一个方程，对于方程使用高斯消元求解。

---


<br/>


<br/>


<br/>


<br/>


# 状态压缩 DP

对于某些 DP 问题，需要记录一个集合以便于进行状态转移。如果集合大小不超过 $N$ ，集合中每个元素都是小于 $K$ 的自然数，那么可以用一个 $N$ 位的 $K$ 进制的整数保存集合， 这就是状态压缩 DP。


### 例题

[**291. 蒙德里安的梦想 - AcWing题库**](https://www.acwing.com/problem/content/293/)

中等偏简单题，状态转移较为简单。

可以把行作为一个维度，设计状态，因为在行与行之间进行状态的转移需要知道前一行的"状态"。

如果上一行的某个位置是竖着的长方形的上半部分，那么该行对应位置就必须是下半部分。所以可以把对应位置为竖着的长方形的上半部分标记为 $1$ ，其余都标记为 $0$ ，并且进行状态压缩为一个整数，则前一行整数和当前行整数与运算结构必须为 $0$ ，或运算结果的二进制表示没一段连续的 $0$ 都是偶数个（可以预处理得出）。


<br/>


[**292. 炮兵阵地 - AcWing题库**](https://www.acwing.com/problem/content/294/)

中等题，状态表示较复杂。

当前行的状态与前两行有关，进行状态转移时，需要知道前两行的形状，所以可以把两行的形状加入状态中， $F(i,j,k)$ 表示前 $i$ 行，第 $i$ 行形状为 $j$ ，第 $i-1$ 行形状为 $j$ 的炮兵部署数量。

如果直接进行递推，时间复杂度为 $O(N\times 2^m\times 2^m\times 2^m)$ ，显然是超时的，可以预处理出集合 $S$ ，其中每个数的二进制表示中相邻的两个 $1$ 之间的距离不小于 $3$ 。

对于本题这种**<span style="background:#fff88f">状态表示比较复杂的情况，不一定要写出确切的状态转移方程，可以使用 DFS 搜索出下个阶段的所有合法的情况，进行递推</span>**。在本题中，也就是以"行"为阶段，相邻两行之间使用 DFS 进行状态转移。


<br/>


[**529. 宝藏 - AcWing题库**](https://www.acwing.com/problem/content/531/)

困难题。

本题有两个关键要点：
- 先打通浅层的宝藏屋，再打通深层的宝藏屋。即从根（中心点）开始一层一层的拓展。
- 对于已经打通的宝藏屋集合 $S$ ，只关心代价最小那一个，打通后续宝藏屋的代价与 $S$ 的内部连接方式无关。

<div align="center"> <img src="https://picture-in-md.oss-cn-guangzhou.aliyuncs.com/2024-05-18_104752.jpg" width = 400 /> </div>


所以可以将层作为第一个维度，将宝藏屋的打通情况进行状态压缩作为第二个维度处理。状态转移方程为：

$$
F\left[ i,j \right] =\underset{valid\left( k,j \right)}{\min}\left\{ F\left[ i-1,k \right] +\left( i-1 \right) \times \cos t\left( k,j \right) \right\} 
$$

其中 $valid(k,j)$ 代表 $k$ 是 $j$ 的子集，并且 $k$ 可以通过拓展得到 $j$ 。 $cost(k,j)$ 表示从 $k$ 扩展到 $j$ 的最小路程的总和。

上述状态转移方程，假设 $k$ 中所有节点都可以拓展，并且深度都是 $i-1$ ，这并不影响最优的答案。

---



<br/>


<br/>


<br/>


<br/>


# 倍增优化 DP

