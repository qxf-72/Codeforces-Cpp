# 最短路

## 单源最短路径

$V$ 为顶点集， $E$ 为边集， $|V|=n$ ， $|E|=m$ 。单源最短路问题就是求从一个出发点到其余各个出发点的最短路径长度的问题。

### Dijkstra 算法

Dijkstra 算法能解决**边权重非负**的有向图（无向图）的单起点最短路径问题。Dijkstra 算法基于贪心思想，每次选出当前距离起点最近的节点进行松弛，当变长都是非负数时，全局最小值不可能再被其他节点更新。


- [**Dijkstra.cpp**](/copypasta/Graph_Theory/Dijkstra.cpp)

	模板代码使用一个优先队列维护距离起点距离最小的节点，应该主义在使用 `priority_queue` 时，在**重载节点的  <  运算符时，不要直接使用全局的  dis[]  直接进行比较**，dis[ ]  数组随时会被更新，可能会让堆失去有序性。一般将距离 d 也作为一个变量放入 NODE 中。

	算法时间复杂度为 $O(m\times log n)$ 。


### 无环有权图最短路算法

Dijkstra 算法不能处理边权为负数的情况。当**图中不含环**时，即使边权为负数，存在时间复杂度为 $O(m+n)$ 的最短路径算法：
- 拓扑排序得到拓扑序列
- 按照拓扑序列进行节点的拓展

算法的正确性很直观，当一个节点被拓展时，在它之间的全部节点不可能会被更新了。


### Bellman-Ford 算法

当图中存在边权为负的情况，我们可能会为了经过负数权值的边而暂时绕更远的路。

朴素 Bellman-Ford 算法，会重复进行 $|V|=n$ 轮的拓展，每一轮中会对所有节点进行拓展，并且不会规定拓展的顺序。时间复杂度为 $O(n\times m)$ 。

朴素 Bellman-Ford 效率较低的根本原因是，在一轮拓展中，许多节点没有必要进行拓展，只有在上一轮被更新的节点，进行拓展才有意义。因此，可以维护一个队列，只有被更新的节点才会放入队列中等待拓展。队列优化的 bellman-Ford 算法又被称为 **SPFA** 。

- [**SPFA.cpp**](/copypasta/Graph_Theory/SPFA.cpp)

	算法在实现时，需要注意使用一个数组标记节点是否在队列中，如果在队列中待拓展，就不再重复入队，节点出队时，需要更新数组。

	 SPFA 在稀疏图上运行效率较高，时间复杂度为 $O(k\times |E|)$ 级别。在稠密图上，算法可能退化为朴素 Bellman-Ford 。

	以上 SPFA 模板代码时检测队列是否为空来确定是否结束循环，**如果图中存在负环（环上权值之和为负），则算法会陷入死循环**。

Bellman-Ford 最多只会拓展 $|V|=n$ 轮，可以**利用 Bellman-Ford 检测负环**——如果进行了 $n$ 轮拓展之后，队列不为空（还需要进行 拓展），则图中存在负环。




---


<br/>


<br/>


## 任意两点之间最短路径

### Floyd 算法

对于图中任意两点的最短路问题，使用求解 $n$ 次的单源最短路问题，这样最好的时间复杂度为 $O(n\times m\times logn)$ 或 $O(n\times m\times k)$ 。当图很稠密时（ $m$ 太大 ）时，使用 Floyd 算法可以在 $O(n^3)$ 时间内完成求解。

Floyd 算法的本质是动态规划， $f(k,i,j)$ 表示节点 $i$ 和 $j$ 之间经过若干个节点编号不超过 $k$ 的节点 的最短路长度。

$$
f\left( k,i,j \right) =\min \left\{ \begin{array}{l}
	f\left( k-1,i,j \right) \ ,\ \text{不经过节点}k\\
	f\left( k-1,i,k \right) +f\left( k-1,k,j \right) \ ,\ \text{经过节点}k\\
\end{array} \right. 
$$

- [**Floyd.cpp**](/copypasta/Graph_Theory/Floyd.cpp)

	需要注意**平行边**的情况，在初始化 dis 数组时，要进行比较。


---


<br/>


<br/>


<br/>


<br/>


# 最小生成树


## Kruskal 算法

Kruskal 算法将所有边按照权值从小到大排序，每一次取出一条边，直到取出 $|V|-1$ 条边，对于每一条加入的边，需要保证和已经加入的边不会构成环。


- [**Kruskal.cpp**](/copypasta/Graph_Theory/Kruskal.cpp)

	算法的主要时间代价在于对边集的排序，时间复杂度为 $O(m\times log m)$ 。

---


<br/>


<br/>

## Prim 算法

Prim 算法总是维护 MST 的一部分，设已经确定属于 MST 的集合为 $T$ ，剩余节点集合为 $S$ ，Prim 算法找到 $\min _{x\in S, y\in T}\left\{ Z \right\}$ ，即两端分别属于集合 $S$ 和 $T$ 的权值最小的边，然后把 $x$ 从集合 $S$ 中删除，然后加入 $T$ 。

可以使用一个数组 dis 维护节点与集合 $T$ 中节点之间权值最小的边的权值。

- [**Prim.cpp**](/copypasta/Graph_Theory/Prim.cpp)

	算法时间复杂度为 $O(n^2)$ ，可以使用二叉堆优化为 $O(m\times logn)$ ，但是使用二叉堆优化还不如使用 Krusal 方便。因此，**Prim 算法主要用于稠密图**。


---