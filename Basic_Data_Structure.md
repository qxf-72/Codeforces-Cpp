# 栈

栈是一种先进后出的线性数据结构。C++STL 中有栈的实现 `stack<>`。以下讨论栈的应用。


## 包含 Min 函数的栈

即入栈、出栈、查询栈中最小值，这三个操作时间复杂度皆为 O (1) 的栈。

首先考虑堆来实现，将元素和下标值存入堆中，这样可以出栈和入栈时更新，但是查询时间复杂度为 log (N)。如果仅仅使用一个变量来记录最小值，这样出栈操作之后，无法得知最小值是否被出栈。

可以使用另一个栈，同步更新历史最小值。

```cpp
class MinStack
{
	stack<int> stk, stk_min;
 public:
	MinStack(){ }

	void push(int x)
	{
		stk.push(x);
		if (stk_min.empty())
			stk_min.push(x);
		else
			stk_min.push(min(stk_min.top(), x));
	}

	void pop()
	{
		if(!stk.empty())
		{
			stk.pop();
			stk_min.pop();
		}
	}

	int top()
	{
		return stk.top();
	}

	int getMin()
	{
		return stk_min.top();
	}
};
```

#### 相关题目

[41. 包含min函数的栈 - AcWing题库](https://www.acwing.com/problem/content/90/)


---


## 出栈序列问题

n 个数字依次进栈，进栈之后可以随时出栈，问有多少种出栈序列。

当不仅仅求序列数量，还需列出序列时，使用 dfs 进行搜索，每一次可以选择将数字入栈，或者将栈顶数字出栈，复杂度 O (2^N)。

如果仅仅序列的数量，等价于求 第 N 项 **Catalan 数**

$$
\frac{C_{2n}^{n}}{n+1}
$$

当 N 很大时，需要结合高精度运算，因为是求组合数，并且不存在分母有质因数 k 而分子没有的情况，所以将卡塔兰数进行质因数分解，然后再计算。


#### 相关题目

[130. 火车进出栈问题 - AcWing题库](https://www.acwing.com/problem/content/132/)
结合**压位高精度**求解和质因数分解求卡塔兰数。

---

## 表达式计算

表达式计算是栈的经典应用，表达式分为三类：
- 中缀表达式：常见的表达式
- 前缀表达式：波兰式，`op A B`
- 后缀表达式：逆波兰式，`A B op`

**后缀表达式求值**
- 遇到一个数，先入栈
- 遇到运算符，将栈顶两个数出栈进行计算，将结果入栈

**中缀表达式转后缀表达式**
- 遇到一个数，直接输出
- 遇到左括号，入栈
- 遇到右括号，不断取栈顶出栈，知道遇到左括号
- 遇到运算符，只要栈顶运算符优先级**大于等于**新运算符（左括号优先级最低，其余按运算优先级排列），不断取栈顶出栈（优先级高的先出栈计算），然后新运算符入栈

---

## 单调栈

单调栈即满足单调性的栈结构。

单调栈适合用于寻找序列中**下一个更大**、**下一个更小**的元素。单调栈就是在遍历序列的同时，根据当前遍历的点元素的大小选择是否将目前栈顶元素弹出，有两种选择策略：
- 当前元素 > 栈顶元素，将栈顶元素弹出：当前元素对于被弹出的元素，就是下一个更大元素。
- 当前元素 < 栈顶元素，将栈顶元素弹出：当前元素对于被弹出的元素，就是下一个更小元素。

可以一直弹出直到不满足条件或者栈为空，然后将当前元素入栈。当遍历完序列之后，栈中的元素必然是单调的，其栈中元素在原序列中不存在下一个更大（更小）的元素（具有 下一个更大（更小元素） 的元素已经在上述遍历过程被弹出栈）。

单调栈常常与**贡献法**结合，贡献法就是考虑每个元素对于答案的贡献，通常结合单调栈寻找元素的作用边界。

#### 模板代码

[**Monotonic_Stack.cpp**](/copypasta/Basic_Data_Structure/Monotonic_Stack.cpp)
模板的代码以下一个更小的元素为例，可以求出该元素前后 第一个更小元素的下标。此时可以得到**以该元素为最小值的最大区间边界**。将数组中的元素取反，此时求的就是下一个更大元素。

通常与贡献法结合，此外还可以求柱状图的最大矩形面积。

#### 相关题目

[131. 直方图中最大的矩形 - AcWing题库](https://www.acwing.com/problem/content/133/)
使用贡献法求解，对于每个元素，求出上一个和下一个 更小元素的 index，得出该元素的作用范围，更新答案。


---


<br/>


<br/>


<br/>


<br/>



# 队列

队列是一种"先进先出"的线性数据结构，为了节省开头空间， 一般将其实现为**循环队列**。C++STL 中有队列的实现 `queue` 和 `deque`。


## 单调队列

给出一个长度为 n 的数组，输出每 k 个连续的数中的最大值、最小值。

以求最大值为例，单调队列维护信息的本质是，一个元素入队时将队内比他小的元素踢出（被踢出元素必然不是当前维护区间的最大值）。

算法步骤：
- 如果当前元素的值 > 队尾元素， **队尾出队**，直到队尾 > 当前元素。然后将当前元素入队。
- 判断队头元素是否超出范围，如果超出就**队头出队**。
- 此时队头就是答案。

根据题目情况，第一步和第二步的执行顺序可能会调换。


#### 相关题目

[135. 最大子序和 - AcWing题库](https://www.acwing.com/problem/content/137/)

---


<br/>


<br/>


<br/>


<br/>




# 链表

链表和二叉树主要是在工作面试中考察。下面讨论 C++STL 中链表的使用，和一些相关算法。

## list 和 forward_list

list 是双向链表。forward_list 为单链表，forward_list 不提供 size 操作，效率接近手写的链表，此外，forward_list 的插入操作与其他容器很不一样，是在指定位置之后插入。

---

## Floyd 判圈算法

> **Floyd判圈算法**(Floyd Cycle Detection Algorithm)，又称**龟兔赛跑算法**(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特-弗洛伊德发明。

该算法可以在不使用常量空间的情况下，使用线性的时间来判断链表是否存在环。主要依赖快慢指针。fast 指针一次走两步，slow 指针一次走一步，如果存在环，两者必定会相遇。

如何**求环的起点**呢？假设慢指针走了 x 步，则快指针走了 2 x 步，设非环部分长度为 a，环长度为 b，可得：

$$
2x-x=kb,即 \ \ x=kb
$$

所以慢指针在环中走了 $kx-a$ 步，如果**再走 $k$ 步**，就是 $(k+1)b$ 步，此时位于**环的起点**。只需要增加一个指针 p 指向头部，和 slow 指针一起移动直到相遇即可。

#### 相关题目

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

---


<br/>


<br/>


<br/>


<br/>


# Hash

## Hash 表

C++STL 中有哈希表的实现 `unordered_map`，但是只有少部分内置类型，有哈希函数，所以很多时候需要自己手写哈希函数。

对于 `unordered_map`，需要提供一个类对象，实现 `()` 的重载，返回类型为 `size_t`。

```cpp
// 自定义pair的哈希函数
struct PairHash {
    template<typename T1, typename T2>
    size_t operator() (const pair<T1, T2>& p) const {
        auto h1 = hash<T1>()(p.first);
        auto h2 = hash<T2>()(p.second);
        // 通过位运算将两个哈希值合并
        return h1 ^ (h2 << 1);
    }
};

int main() {
    // 定义一个pair类型的哈希表
    unordered_set<pair<int, int>, PairHash> myset;
    // 向哈希表中插入元素
    myset.insert({1, 2});
    myset.insert({3, 4});

    // 遍历哈希表
    for (auto& p : myset) {
        cout << "(" << p.first << ", " << p.second << ")" << endl;
    }

    return 0;
}
```

`unordered_map` 的哈希函数一般而言不应该生产哈希值的冲突，如果可能存在冲突，可以将 value 的类型设置为 vector，或者 list。将冲突的全部放在一起，之后进行线性查找。

#### 相关题目

---


## 字符串 Hash

将一个任意长度的字符串映射为非负整数，冲突概率几乎为 0。具体做法——将字符串看作是一个 P 进制数，求出这个数，然后对 M 取余。
- P 通常取 **131** 或 **13331**。
- M 通常取 $2^{64}$ ，直接使用 **unsigned long long** 存储这个数，高位自动对齐，不用取余操作。

除了特殊构造的字符串，该哈希很难产生冲突。为了将冲突的可能性再次降低，可以多取几个不同的 P 和 M，结果都相同时，才认为字符串相等。

字符串 Hash 的主要用处是——进过 O (N) 时间预处理后，可以 **以 O(1) 时间查询任意子字符串的哈希值**。
- $H(S+c)=(H(S)*P+value(c))\  \% \  M$
- $H(T)=(H(S+T)-H(S)^{len(T)}) \  \%  \ M$

为了降低计算复杂度，P 的次方也可以预处理保存到一个数组里面。

#### 相关题目


---