# 树与图的遍历

## 拓扑排序

不断选择图中入度为 0 的节点入队，然后把 该节点连向的节点 入度 -1 。具体流程如下：
- **预处理**所有点的入度，把所有入度为 0 的节点入队。
- 取出队头节点 x，把 x 加入拓扑序列尾部。
- 对于从 x 出发的边 (x, y)，把 y 的入度-1，如果减少为 0，y 入队。
- 重复上面步骤直到队列为空。

拓扑排序可以**判断有向图中是否存在环**——拓扑序列长度是否小于图中点的数量。原理很简单——环上的节点入度不可能为 0，永远无法入队被处理，所以无法被加入拓扑序列中。

### 相关题目

[164. 可达性统计 - AcWing题库](https://www.acwing.com/problem/content/166/)
想要知道当前节点可达点数，需要先取出与之直接相邻的之后的点可达情况。所有先进行拓扑排序，然后倒序进行统计，在统计时，可以使用 `bitset` 进行或操作。

---


<br/>


<br/>


<br/>


<br/>


# 深度优先搜索

深度优先搜索，就是按照当前路径深度从大到小排序，优先出队拓展的搜索算法。


### 例题

[2151. 基于陈述统计最多好人数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-good-people-based-on-statements/description/)
数据量很小，可以 dfs 或者二进制枚举，关键在于判断一种状态是否合法，关键在于集合中两个好人说的话不能相冲突。


[AcWing 165. 小猫爬山 - AcWing](https://www.acwing.com/activity/content/problem/content/400/)
递归处理每只小猫的分配过程，对于每只小猫，要么从已分配到缆车中，挑一个放进去，要么新增一个缆车。为了使得搜索更高效，可以进行优化——重量大的小猫更难运送，所以可以先处理重量大的小猫。

[166. 数独 - AcWing题库](https://www.acwing.com/problem/content/168/)
优先尝试能够填写数字较少的位置。


---


<br/>


<br/>


<br/>


<br/>


# 剪枝

剪枝，就是减小搜索树规模，尽早排除搜索树中不必要分支的一种手段。具体手段有：
- 优化搜索顺序：在上一节例题中，小猫爬山优先搜索重量大的小猫；数独优先填写能够填写的选择较少的格子。**关键在于优先处理比较苛刻的节点，以尽早剪除不可能的分支**。
- 排除等效冗余：当前节点的不同分支延伸是等效的。
- 可行性剪枝：如果分支已经无法到达递归边界，就尽早回溯。
- 最优化剪枝：如果当前代价超过了当前搜索到了最后解，就尽早回溯。
- 记忆化：记录每个状态的搜索结果，不必重复遍历。

### 例题

[167. 木棒 - AcWing题库](https://www.acwing.com/problem/content/169/)
优化搜索顺序，把木棒从大到小排序。排序等效冗余，记录上一次添加小木棒的 idx。

[168. 生日蛋糕 - AcWing题库](https://www.acwing.com/problem/content/170/)
从底层向高层搜索，同时进行剪枝优化：
- 对于确定的 r 和 h 的范围，可以从大到小来枚举，因为越大的越容易超过限制，所以可以尽早排除出答案。
- 预处理从上打下的最小体积和表面积，一旦当前+后续最小的还是超过限制，直接回溯。
- 最优性剪枝，如果当前代价超过已经搜索到的最小代价，直接回溯。

[169. 数独2 - AcWing题库](https://www.acwing.com/problem/content/171/)



---


<br/>


<br/>


<br/>


<br/>


# 迭代加深

## 迭代加深

深度优先搜索（iterative-deepening search），每次选择一个分支不断深入，直到递归边界才回溯，如果一旦选了错误的分支，会在不包含答案的深层分支上浪费许多时间。广度优先搜索，需要使用队列存储待拓展的节点，随着深度增加，需要的空间会爆炸性增长。

迭代加深，结合了深度优先和广度优先的特点，本质上还是使用 DFS 方式拓展，但是限制了拓展的深度。如果超过指定深度 d 就马上返回。

### 例题

[170. 加成序列 - AcWing题库](https://www.acwing.com/problem/content/172/)
题目不仅要求找到可行解，还要求路径长度最小，如果使用 dfs，每找到一个解就需要更新维护答案，如果使用 bfs，空间爆炸性增长。不妨使用迭代加深，**为了保证找到的第一个答案就是最短的，必须限制每次加大的深度为一**。

---

## 双向搜索

除了迭代加深，双向所有也可以避免在深层子树上浪费时间。

在一些题目中，问题不但具有"初态"，还具有明确的"终态"，可以进行双向的搜索——从初态和终态出发各搜索一半的状态。


### 例题

[171. 送礼物 - AcWing题库](https://www.acwing.com/problem/content/173/)
超大体积背包问题。直接解法是对每一个礼物进行枚举，时间复杂度为 $O(2^{45})$ ，显然无法接受。但是如果分两段进行枚举，然后将两段的各种能装入背包的重量，进行二分。总时间复杂度为 $O(2^{n/2}+n\times logn)$ 。

---


<br/>


<br/>


<br/>


<br/>


# 广度优先搜索

广度优先搜索，从一个中心点不断向外进行扩展，常用于求解一些从一个状态转移到另一个状态的最短路径/步数问题。

广度优先搜索的队列中具有以下性质：
- **两段性**：最多只有两层不同的节点在队列中。
- **单调性**：从队头到队尾，代价是增加的（或者不减的）。


### 例题

[172. 立体推箱子 - AcWing题库](https://www.acwing.com/problem/content/174/)
题目本意并不难，需要设计好如果记录状态，以及不同状态之间的转移。代码量较大，对调试能力要求较高。

[173. 矩阵距离 - AcWing题库](https://www.acwing.com/problem/content/175/)
存在多个起点，先预处理放入 queue 中，再开始 bfs。

[174. 推箱子 - AcWing题库](https://www.acwing.com/problem/content/description/176/)
将箱子的状态和人的状态打包成一个三元组，之后进行拓展，同时需要记录从哪一个状态转移而来的，以便于输出路径。也可以采用变形广搜，使用优先队列保持队列性质。

---


<br/>


<br/>


<br/>


<br/>


# 广搜变形

## 双端队列 BFS

基本的 BFS，每次沿着分支的拓展都记为 1 步，通过从起点开始往外拓展搜索，可以解决起始状态到每个状态最小步数的问题。

本质上等价于在一张边权均为 1 的图上执行广度优先遍历。当图中的边权不全为 1 时，无法保证队列中的单调性。

当**图中边权只有 0 和 1** 时，可以使用双端队列保持单调性：
- 对于边权为 0 的，拓展后放入队头。
- 对于边权为 1 的，拓展后放入队尾。


### 例题

[175. 电路维修 - AcWing题库](https://www.acwing.com/problem/content/177/)
可以将电路板中每个格点，看作是一个节点。问题等于是求点（0,0）到（n, m）的最短路径，可以使用 Dijkstra 算法，每次取出路径权值和最小的点进行拓展，这种算法肯定是正确的。在本题中，由于边权很特殊，只有 0 和 1，完全可以使用双端队列来代替 Dijkstra 算法中的优先队列，其余操作和最短路算法一样。

**为什么不能像朴素 BFS 那样每个节点更新一次**？在朴素 BFS 中，路径的权值永远是 1，因为路径一样，所以先到达一个节点的路径就是最短路径，但是本题中存在边权为 0 的边，并不能保证先到达的就是最短的。

**有没有可能某个电缆被旋转了两次呢**？这是不可能的。因为起点是 ( 0 , 0 )而每次走一条边，都会使得两坐标之和 x + y 变化− 2 , 0 , + 2 ，所以 x + y 永远都是偶数，而如果某个电缆被旋转两次的话，就说明走到了路径再次拓展到了（x-1，y）或者（x，y-1），即 x + y 是奇数的顶点，这是不可能的。同时我们也得到了一个结论，就是如果 n + m  是奇数，那么一定无解。


---

## 优先队列 BFS

对于更普遍的情况，每次拓展有着各自不同的代价，需要求出起点状态到不同状态的最小代价，有以下两种方案：

- 朴素 BFS：此时不能保证每个状态第一次入队就能得到最小代价，所以允许一个状态多次被更新进出队列。最坏情况下，时间复杂度为 O (N^2)。
- 优先队列 BFS：在**代价（边权）不为负**的情况下，每次从优先队列中取出代价最小的节点进行拓展（之后不用进行更新），时间复杂度为 O (N logN)。

### 例题

[176. 装满的油箱 - AcWing题库](https://www.acwing.com/problem/content/178/)
使用一个三元组（city，fuel，cost）记录每一个状态，使用数组 d[ city ][ fuel ] 记录最下花费。应该注意的是，在使用 priority_queue 时，**状态节点需要记录 cost 状态，而不是使用数组 d[ city ][ fuel ]进行比较，因为数组的值是会被修改，可能会导致堆中失去二叉堆的有序性，而不能被及时调整，**导致一些意想不到的后果。

----

## 双向 BFS

双向 BFS 思想和双向搜索相同。从起点状态和终点状态分别出发，两边轮流进行各自拓展一轮。当两边各自有一个状态在记录数组中发生重复，说明两个搜索相遇。


### 例题

[177. 噩梦 - AcWing题库](https://www.acwing.com/problem/content/179/)
同时在男孩和女孩位置开始进行 bfs，每一轮 t，各自进行拓展，男孩拓展 3 轮，女孩拓展 1 轮。同时需要注意，鬼在每一轮开始是先移动的。控制拓展轮数代码如下：

```cpp
size_t sz;
for (int i = 1; i <= 3; ++i)
{
	sz = boy.size();	// 这里需要额外注意
	for (int j = 1; j <= sz; ++j)
	{
		auto [x, y] = boy.front();
		boy.pop();
		if (!valid(x, y, t)) continue;
		for (int k = 0; k < 4; ++k)
		{
			int nx = x + dx[k], ny = y + dy[k];
			if (valid(nx, ny, t) && !bv[nx][ny])
			{
				bv[nx][ny] = true;
				boy.emplace(nx, ny);
			}
		}
	}
}
```


---



<br/>


<br/>


<br/>


<br/>


# A *

A* 是启发式搜索的一种。对于问题，能够设计启发式函数——估计当前状态到目标状态的代价，**启发式函数必须是乐观的**，即，启发式函数得到的代价不应该比实际代价大。

使用一个优先队列存储状态，以**h (x)=当前代价 f (x) + 启发式函数预估代价 h (x)**作为比较的标准，每次取出最小的 h 进行拓展。

当 h=0 时，A* 算法变为 Dijsktra 算法，若此时边权皆为 1，变为 BFS 算法。


### 例题

[178. 第K短路 - AcWing题库](https://www.acwing.com/problem/content/180/)

**第 k 短路问题**——**对于一个节点，当该节点第 i 次从堆中被取出，就得到了从起点到该节点第 i 短路径的长度**。

朴素做法最坏时间复杂度为 $O(k\times (m+n)log(m+n))$ 。由于给定了起点 s 和终点 t，在此情况下，可以考虑使用启发式搜索，使用 dijkstra 算法在反向图上求 t 到其他各个点的最短路，这样就可以得到每个节点到 t 的最短距离，其符合启发式函数的要求。


[179. 八数码 - AcWing题库](https://www.acwing.com/problem/content/181/)

可以根据数字的当前位置和最终位置的曼哈顿距离估计最小操作次数。

---


<br/>


<br/>


<br/>


<br/>


# IDA *

**ID A***，即迭代加深的 **A*** 算法。

A\* 算法本质是带有启发式估值函数的 优先队列 BFS 算法，所以同样有着 BFS 算法的缺点，需要一个队列存储待拓展节点，耗费空间较大，并且对堆操作一下需要花费 O (logN)时间。

把估值函数和迭代加深 DFS 结合起来，得到 **IDA***，同样的启发式函数也必须是**乐观的**。把原来简单的深度限制，改为：若 **当前深度+预估步数>深度限制**，立即回溯。IDA\* 在许多场景下表现出优秀的效率，且程序实现难度小于 A\*。

```cpp
bool IDA_star(int depth,int limit)
{
	// 达到目标状态
	if(check())
		return true;
	// 剪枝
	if(depth+f()>limit)
		return false;
	// 枚举进行操作，可以考虑搜索顺序的优化
	for( ; ; )  {
		// 操作
		if(IDA_star(depth+1,limit))
			return true;
		// 恢复现场
	}
}
```


### 例题

[180. 排书 - AcWing题库](https://www.acwing.com/problem/content/182/)

在目标状态下，第 i 本书之后应该是第 i+1 本书，**可以统计序列的错误后继数 t，可以发现每次更改最多可以改变 3 个后继**，可以设置估计函数为 $f\left( s \right) =\lceil \frac{t}{3} \rceil$ 。使用 IDA\*求解。


[181. 回转游戏 - AcWing题库](https://www.acwing.com/problem/content/183/)

估值函数设计——中间 8 个各自出现次数最多数字出现次数为 k，则至少需要移动 8-k 次。


[182. 破坏正方形 - AcWing题库](https://www.acwing.com/problem/content/184/)

首先可以枚举当前移除哪一根火柴棒，考虑使用 A\*，使用 BFS 式的搜索，需要维护当前移除了哪些火柴棒，每一层的分支较多，所需空间太大。所以考虑使用 DFS 式搜索——IDA\*，关键在于设计估值函数——不断从当前图像中，选出还没有被破坏的正方形，去掉他边界上所有火柴棒，但是只记作一次操作，这样得到的估值函数必然是乐观的。

其中还涉及到一些剪枝的操作：
- 先对完整的小正方形进行操作
- 如果对当前小正方形操作全都失败，立即回溯

---